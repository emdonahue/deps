#!/bin/zsh

# REQUIREMENTS:
# HISTFILE should be set in .zshrc
# should be run as a shell function not a script

setopt extendedglob
fc -R

function parse_recipe() {
    local -U DEPENDENCIES=()
    local IFS=$IFS')(><|'
    for D in "${=2}"; do
	if [[ -f "$D" && "$D" != "$1" ]]; then
	    DEPENDENCIES+=("$D")
	fi
    done
    echo "$DEPENDENCIES[@]"
}

function makefile() {
    local MAKEFILE=$(print -l (../)#Makefile(:a) | head -n1) 2>/dev/null
    [[ ! -f "$MAKEFILE" ]] && echo "Makefile not found. Use $(basename "$0") init." 1>&2 && exit 1
    echo "$MAKEFILE"
}

local CMD="$1"
[[ $# -ne 0 ]] && shift

case "$CMD" in

    add) #[FILE...], Scans history to determine the recipe that created each FILE (looks for ">"). Dependencies are automatically detected based on currently existing filenames mentioned in the recipe. Use set to add a recipe explicitly if these heuristics fail.
	#fc -rLnlm '*>\|(#c0,1) #'"$f" | head -n1
	for f in "$@"; do	    
	    local RECIPE=$(fc -lnLr -l 1 | grep -E '>\|?\s*'"$f" | head -n1)
	    if [[ -z "$RECIPE" ]]; then
		echo "No recipe found for $f" >&2
	    else
		"$0" set "$f" "$(parse_recipe "$f" "$RECIPE")" <<< "$RECIPE"
	    fi
	done	    
	;;

    comment) #TARGET [COMMENT], Sets or prints a short comment associated with the recipe for TARGET. Useful for quick notes annotating generated files. If COMMENT is present, set the comment, otherwise print.
	if [[ $# -eq 0 ]]; then
	    "$0" help "$CMD"
	elif [[ $# -eq 1 ]]; then
	    grep -E '^'"$1"':' Makefile | sed -E 's/[^#]*#(.*)/\1/'
	else
	    sed -Ei -- '/^'"$1"':/ s/([^#]*)#?.*/\1#'"${*:2}"'/' Makefile
	fi
	;;

    edit) #TARGET, Places the recipe for TARGET on the command line so it can be modified and re-added to the Makefile if needed.
	#local RECIPE=$(sed -n '/^'"${1:gs_/_\\/_}"':/{n;p}' Makefile | sed 's/\$\$/$/g')
	#print -z "$CMD"
	echo "testing"
	print -z "test cmd"
	;;

    init) #, Creates a new Makefile in the current directory. Use before other commands that attempt to modify the Makefile.
	[[ -f Makefile ]] && {echo 'Makefile already exists' 1>&2; exit 1}
	echo 'SHELL=zsh -i' >> Makefile
	echo '.PHONY: all clean' >> Makefile
	echo 'TARGETS=$(shell sed -nE "/^[^[:space:]]*:/ s/:.*//p" Makefile | grep -v -e "^all$$" -e "^clean$$" -e "^\.PHONY$$")' >> Makefile
	echo 'all: $(TARGETS)' >> Makefile
	echo 'clean:' >> Makefile
	echo '\trm -f $(TARGETS)' >> Makefile
	;;
    
    rm) #TARGET, Unsets the recipe for building TARGET from the Makefile and deletes the corresponding file.	
	"$0" unset "$1"
	rm -f "$1"
	;;
    --help|-h|help) #[SUBCOMMAND], Prints help text for SUBCOMMAND. If SUBCOMMAND omitted, prints list of subcommands.
	if [[ $# -eq 0 ]] && echo 'deps - Automatic Makefile generation and dependency management from command line history\nUsage: deps SUBCOMMAND [ARGUMENTS...]\nSubcommands:'
	grep -E -- "${1:-\\w+}\)\s#" "$0" | sed -E -- "s/^[[:space:]]*([-|[:alpha:]]+)\)\s#([^,]*), (.*)/\1 \2 - \3/" | sed $((${+1}+1))',$ s/^[[:space:]]*/\t/'
	;;
    set) #TARGET [DEPENDENCY...], Creates a new recipe for TARGET using DEPENDENCY and a recipe from stdin.
	if [[ ! -f Makefile ]]; then
	    
	fi
	
    	"$0" unset "$1"
	echo -n "$1: " >> Makefile
	shift
	echo "$@" >> Makefile
	<&0 sed -e 's/^/\t/' -e 's/\$/$$/g' >> Makefile
	;;
    
    unset) #TARGET, Deletes the recipe for building TARGET from the Makefile.
	awk -i inplace "/^$1/ {skip=1; next} skip && !/^\s/ {skip=0} !skip {print}" Makefile
	;;
    
    *)
	"$0" help
	;;
esac
