#!/bin/zsh

# REQUIREMENTS:
# HISTFILE should be set in .zshrc
# should be run as a shell function not a script

function deps() {
    
    setopt extendedglob
    
    local CMD="$1"
    [[ $# -ne 0 ]] && shift

    # Find Makefile for subcommands that require it
    case "$CMD" in
	-h|--help|help|init);;
	*)
	    local MAKEFILE=$(print -l (../)#Makefile(:a) | head -n1) 2>/dev/null	    
	    [[ ! -f "$MAKEFILE" ]] && echo "Makefile not found. Use $(basename "$0") init." 1>&2 && return 1
	    local RELPATH=${$(echo $(pwd)'/')#$(echo $(dirname "$MAKEFILE")'/')}
	    ;;
    esac

    # Parse the main subcommand
    case "$CMD" in

	add) #[FILE...], Scans history to determine the recipe that created each FILE (looks for ">"). Dependencies are automatically detected based on currently existing filenames mentioned in the recipe. Use set to add a recipe explicitly if these heuristics fail.
	    for f in "$@"; do
		local RECIPE=$(fc -nrl -1000 | grep -E '>\|?\s*'"$f" | head -n1)
		if [[ -z "$RECIPE" ]]; then
		    echo "No recipe found for $f" >&2
		else
		    local -U DEPENDENCIES=()
		    local IFS=$IFS')(><|'
		    for D in "${=RECIPE}"; do			
			if [[ -f "$D" && "$D" != "$1" ]]; then
			    RECIPE=$(sed -E "s|\b$D\b|$RELPATH$D|g"<<< "$RECIPE")
			    DEPENDENCIES+=("$RELPATH$D")
			fi
		    done
		    RECIPE=$(sed -E "s|\b$f\b|$RELPATH$f|g"<<< "$RECIPE")
		    echo "Recipe added to $MAKEFILE:\n$RELPATH$f $DEPENDENCIES\n\t$RECIPE"
		    "$0" set "$RELPATH$f" "$DEPENDENCIES" <<< "$RECIPE"
		fi
	    done
	    ;;

	comment) #TARGET [COMMENT], Sets or prints a short comment associated with the recipe for TARGET. Useful for quick notes annotating generated files. If COMMENT is present, set the comment, otherwise print.
	    if [[ $# -eq 0 ]]; then
		"$0" help "$CMD"
	    elif [[ $# -eq 1 ]]; then
		grep -E '^'"$1"':' "$MAKEFILE" | sed -E 's/[^#]*#(.*)/\1/'
	    else
		sed -Ei -- '/^'"${1:gs_/_\\/_}"':/ s/([^#]*)#?.*/\1#'"${*:2:gs_/_\\/_}"'/' "$MAKEFILE"
	    fi
	    ;;

	edit) #TARGET, Places the recipe for TARGET on the command line so it can be modified and re-added to the Makefile if needed.
	    local MAKEFILE="$MAKEFILE"	
	    [[ ! -f "$MAKEFILE" ]] && return 1
	    local RECIPE=$(sed -n '/^'"${1:gs_/_\\/_}"':/{n;p}' "$MAKEFILE" | sed 's/\$\$/$/g')	
	    local RECIPE=$(sed -n '/^'"${1:gs_/_\\/_}"':/{n;p}' "$MAKEFILE" | sed 's/\$\$/$/g;s/^[[:space:]]*//')
	    [[ -z "$RECIPE" ]] && echo "No recipe for $1 found in $MAKEFILE" && return 1
	    print -z "$RECIPE"
	    ;;

	--help|-h|help) #[SUBCOMMAND], Prints help text for SUBCOMMAND. If SUBCOMMAND omitted, prints list of subcommands.
	    echo "grepping: $(realpath $0)"
	    [[ $# -eq 0 ]] && echo 'deps - Automatic Makefile generation and dependency management from command line history\nUsage: deps SUBCOMMAND [ARGUMENTS...]\nSubcommands:'
	    grep -E -- "${1:-\\w+}\)\s#" "$functions_source[$0]" | sed -E -- "s/^[[:space:]]*([-|[:alpha:]]+)\)\s#([^,]*), (.*)/\1 \2 - \3/" | sed $((${+1}+1))',$ s/^[[:space:]]*/\t/'
	    ;;
	
	init) #, Creates a new Makefile in the current directory. Use before other commands that attempt to modify the Makefile.
	    [[ -f Makefile ]] && {echo 'Makefile already exists' 1>&2; return 1}
	    echo 'SHELL=zsh -i' >> Makefile
	    echo '.PHONY: all clean' >> Makefile
	    echo 'TARGETS=$(shell sed -nE "/^[^[:space:]]*:/ s/:.*//p" Makefile | grep -v -e "^all$$" -e "^clean$$" -e "^\.PHONY$$")' >> Makefile
	    echo 'all: $(TARGETS)' >> Makefile
	    echo 'clean:' >> Makefile
	    echo '\trm -f $(TARGETS)' >> Makefile
	    ;;

	less) #, Opens the Makefile in less.
	    less "$MAKEFILE"
	    ;;
	
	mv) #SOURCE DEST, Moves a file with mv and updates the Makefile accordingly.
	    mv -i "$1" "$2"
	    local a=$(realpath --relative-to=$(dirname "$MAKEFILE") "$1")
	    local b=$(realpath --relative-to=$(dirname "$MAKEFILE") "$2")
	    sed -i "s/\b${a:gs_/_\\/_}\b/${b:gs_/_\\/_}/g" "$MAKEFILE"
	    ;;

	rm) #TARGET, Unsets the recipe for building TARGET from the Makefile and deletes the corresponding file.
	    "$0" unset "$1"
	    rm -f "$1"
	    ;; 

	set) #TARGET [DEPENDENCY...], Creates a new recipe for TARGET using DEPENDENCY and a recipe from stdin.
    	    "$0" unset "$1"
	    echo -n "$1: " >> "$MAKEFILE"
	    shift
	    echo "$@" >> "$MAKEFILE"
	    <&0 sed -e 's/^/\t/' -e 's/\$/$$/g' >> "$MAKEFILE"
	    ;;

	unset) #TARGET, Deletes the recipe for building TARGET from the Makefile.
	    awk -i inplace "/^${1:gs_/_\\/_}/ {skip=1; next} skip && !/^\s/ {skip=0} !skip {print}" "$MAKEFILE"
	    ;;

	*)
	    "$0" help
	    ;;
    esac
}
